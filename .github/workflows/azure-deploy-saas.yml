name: Deploy AI Event Planner SaaS to Azure

on:
  push:
    branches:
      - main
    paths:
      - 'app/**'
      - 'migrations/**'
      - 'alembic.ini'
      - 'requirements.txt'
      - '.github/workflows/azure-deploy-saas.yml'
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        poetry install --without google --no-root || (sleep 10 && poetry install --without google --no-root)
        # Install additional test dependencies to fix CI issues
        pip install psutil email-validator
    
    - name: Create .env.test if missing and run tests
      run: |
        # Check if .env.test exists, if not create it
        if [ ! -f .env.test ]; then
          echo "Warning: .env.test not found. Creating default test environment file..."
          cat > .env.test << 'EOF'
        # AI Event Planner Test Environment Variables
        
        # OpenAI API Configuration (Required for real agents)
        OPENAI_API_KEY=sk-test-placeholder-for-testing
        
        # LLM Configuration
        LLM_MODEL=gpt-4
        LLM_PROVIDER=openai
        
        # Optional API Keys for enhanced functionality (use test/placeholder values)
        TAVILY_API_KEY=test_tavily_api_key_here
        GOOGLE_API_KEY=test_google_api_key_here
        SENDGRID_API_KEY=test_sendgrid_api_key_here
        OPENWEATHER_API_KEY=test_openweather_api_key_here
        
        # Database Configuration (Use in-memory SQLite for tests)
        DATABASE_URL=sqlite:///:memory:
        
        # Application Configuration
        SECRET_KEY=test_secret_key_for_testing_only
        DEBUG=false
        ENVIRONMENT=test
        
        # Server Configuration
        HOST=0.0.0.0
        PORT=8000
        EOF
        fi
        
        # Copy .env.test to .env for running tests
        cp .env.test .env
        
        # Export environment variables for tests
        set -a
        source .env
        set +a
        
        # Create mock MCP server file to prevent test failures
        mkdir -p mcp-servers/sendgrid-mcp/build
        echo "module.exports = {};" > mcp-servers/sendgrid-mcp/build/index.js
        
        # Run tests with CI optimizations for faster execution
        CI=true poetry run pytest -x --tb=short --disable-warnings -q
    
    - name: Verify required secrets are available
      env:
        AZURE_LOCATION: ${{ secrets.AZURE_LOCATION }}
        AZURE_RESOURCE_GROUP: ${{ secrets.AZURE_RESOURCE_GROUP }}
      run: |
        if [ -z "${AZURE_RESOURCE_GROUP:-}" ]; then
          echo "ERROR: AZURE_RESOURCE_GROUP is not available to this job"
          exit 1
        else
          echo "AZURE_RESOURCE_GROUP is available"
        fi
        if [ -z "${AZURE_LOCATION:-}" ]; then
          echo "ERROR: AZURE_LOCATION is not available to this job"
          exit 1
        else
          echo "AZURE_LOCATION is available"
        fi
    
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Ensure Azure Web App exists (create if missing / respect existing RG location)
      run: |
        set -euo pipefail

        # Use secrets (or hardcoded defaults)
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"                 # e.g. ai-event-planner-rg
        DESIRED_LOCATION="${{ secrets.AZURE_LOCATION }}"         # e.g. westus2 (optional)
        APP_NAME="ai-event-planner-saas-py"
        PLAN_NAME="ai-event-planner-plan"
        SKU="B1"

        echo "Resource Group: $RG"
        if az group show --name "$RG" >/dev/null 2>&1; then
          EXISTING_LOCATION=$(az group show --name "$RG" --query location -o tsv)
          echo "Resource group '$RG' already exists in location: $EXISTING_LOCATION"

          if [ -n "${DESIRED_LOCATION:-}" ] && [ "$DESIRED_LOCATION" != "$EXISTING_LOCATION" ]; then
            echo "Warning: desired location ($DESIRED_LOCATION) differs from existing group location ($EXISTING_LOCATION)."
            echo "Proceeding using existing resource group location: $EXISTING_LOCATION"
          fi

          LOCATION="$EXISTING_LOCATION"
        else
          # Create the resource group in DESIRED_LOCATION (fail if not provided)
          if [ -z "${DESIRED_LOCATION:-}" ]; then
            echo "ERROR: Resource group '$RG' does not exist and AZURE_LOCATION is not set. Set the AZURE_LOCATION secret or create the RG manually."
            exit 1
          fi
          echo "Creating resource group '$RG' in location: $DESIRED_LOCATION"
          az group create --name "$RG" --location "$DESIRED_LOCATION"
          LOCATION="$DESIRED_LOCATION"
        fi

        echo "Using Location: $LOCATION"

        # Create App Service plan if missing (Linux plan)
        if ! az appservice plan show --name "$PLAN_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating App Service plan: $PLAN_NAME"
          az appservice plan create --name "$PLAN_NAME" --resource-group "$RG" --sku "$SKU" --is-linux
        else
          echo "App Service plan '$PLAN_NAME' already exists."
        fi

        # Create the web app if missing (Python 3.10)
        if ! az webapp show --name "$APP_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating Web app: $APP_NAME"
          az webapp create --resource-group "$RG" --plan "$PLAN_NAME" --name "$APP_NAME" --runtime "PYTHON|3.10"
        else
          echo "Web app '$APP_NAME' already exists."
        fi
    
    - name: Set up environment variables
      run: |
        echo "DATABASE_URL=${{ secrets.DATABASE_URL }}" >> .env.azure
        echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" >> .env.azure
        echo "STORAGE_CONNECTION_STRING=${{ secrets.STORAGE_CONNECTION_STRING }}" >> .env.azure
        echo "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" >> .env.azure
        echo "GOOGLE_API_KEY=${{ secrets.GOOGLE_API_KEY }}" >> .env.azure
    
    - name: Create deployment package
      run: |
        mkdir -p deploy
        cp -r app deploy/
        cp -r migrations deploy/
        cp -r scripts deploy/
        cp alembic.ini deploy/
        cp requirements.txt deploy/
        cp startup.sh deploy/
        
        # Make startup script executable
        chmod +x deploy/startup.sh
        
        # Create zip file
        cd deploy
        zip -r ../deploy.zip .
        cd ..
    
    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: 'ai-event-planner-saas-py'
        slot-name: 'production'
        package: './deploy.zip'
    
    - name: Configure Azure Web App
      run: |
        # Use the startup.sh script
        az webapp config set --name ai-event-planner-saas-py --resource-group ai-event-planner-rg --startup-file "./startup.sh"
        
        # Set essential environment variables with fallbacks
        az webapp config appsettings set --name ai-event-planner-saas-py --resource-group ai-event-planner-rg --settings \
          "DATABASE_URL=${{ secrets.DATABASE_URL }}" \
          "SECRET_KEY=${{ secrets.SECRET_KEY }}" \
          "OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}" \
          "GOOGLE_API_KEY=${{ secrets.GOOGLE_API_KEY }}" \
          "TAVILY_API_KEY=${{ secrets.TAVILY_API_KEY }}" \
          "LLM_PROVIDER=openai" \
          "LLM_MODEL=gpt-4" \
          "HOST=0.0.0.0" \
          "PORT=8000" \
          "ENVIRONMENT=production" \
          "PYTHONPATH=/home/site/wwwroot"
    
    - name: Install Azure CLI extensions and run database migrations
      run: |
        # Display Azure CLI info for debugging
        echo "Azure CLI version:"
        az --version
        
        echo "Current extensions:"
        az extension list --output table
        
        # Install db-up extension with robust error handling
        echo "Installing/updating db-up extension..."
        if ! az extension add --name db-up 2>/dev/null; then
          echo "Failed to add db-up extension, trying update..."
          if ! az extension update --name db-up 2>/dev/null; then
            echo "Failed to install/update db-up via az extension, skipping extension-dependent operations..."
            echo "Note: db-up extension may not be needed for current migration approach"
          fi
        fi
        
        # Check if jq is installed
        if ! command -v jq &> /dev/null; then
          echo "Warning: jq is not installed. Using alternative approach."
          
          # Get publishing credentials using direct Azure CLI queries
          USERNAME=$(az webapp deployment list-publishing-credentials --resource-group ai-event-planner-rg --name ai-event-planner-saas-py --query publishingUserName -o tsv)
          PASSWORD=$(az webapp deployment list-publishing-credentials --resource-group ai-event-planner-rg --name ai-event-planner-saas-py --query publishingPassword -o tsv)
        else
          # Get publishing credentials using jq
          CREDS=$(az webapp deployment list-publishing-credentials --resource-group ai-event-planner-rg --name ai-event-planner-saas-py --query "{username:publishingUserName, password:publishingPassword}" -o json)
          USERNAME=$(echo $CREDS | jq -r '.username')
          PASSWORD=$(echo $CREDS | jq -r '.password')
        fi
        
        # First, find the Python executable path
        echo "Finding Python executable path..."
        FIND_PYTHON_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
          -H "Content-Type: application/json" \
          https://ai-event-planner-saas-py.scm.azurewebsites.net/api/command \
          -d "{\"command\":\"find / -name python3 2>/dev/null | head -n 1\", \"dir\":\"/\"}")
        
        # Extract status code and response body
        FIND_PYTHON_HTTP_STATUS=$(echo "$FIND_PYTHON_RESPONSE" | tail -n1)
        FIND_PYTHON_BODY=$(echo "$FIND_PYTHON_RESPONSE" | sed '$d')
        
        echo "Find Python response: $FIND_PYTHON_BODY"
        echo "HTTP status: $FIND_PYTHON_HTTP_STATUS"
        
        # Extract Python path from the response
        PYTHON_PATH=$(echo "$FIND_PYTHON_BODY" | grep -o '/[a-zA-Z0-9/_.-]*python3' | head -n 1 || echo "")
        
        if [ -z "$PYTHON_PATH" ]; then
          echo "Python path not found, using default /usr/local/bin/python3"
          PYTHON_PATH="/usr/local/bin/python3"
        else
          echo "Found Python path: $PYTHON_PATH"
        fi
        
        # Use the Python path to run the migration script
        echo "Running migrations..."
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
          -H "Content-Type: application/json" \
          https://ai-event-planner-saas-py.scm.azurewebsites.net/api/command \
          -d "{\"command\":\"$PYTHON_PATH -m scripts.migrate\", \"dir\":\"/home/site/wwwroot\"}")
        
        # Extract status code and response body
        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
        
        echo "Migration response: $RESPONSE_BODY"
        echo "HTTP status: $HTTP_STATUS"
        
        # Check if the request was successful
        if [ "$HTTP_STATUS" -ne 200 ]; then
          echo "Migration failed with status $HTTP_STATUS"
          echo "Response: $RESPONSE_BODY"
          exit 1
        fi
        
        # Check if the response contains error messages
        if echo "$RESPONSE_BODY" | grep -i "error"; then
          echo "Migration script reported errors"
          exit 1
        fi
        
        echo "Migration completed successfully"
    
    - name: Logout from Azure
      run: |
        # Check if there are active accounts before logging out
        if az account show &>/dev/null; then
          echo "Logging out from Azure..."
          az logout
        else
          echo "No active Azure sessions to logout from"
        fi
      if: always()
    
    - name: Cleanup
      run: |
        rm -rf deploy
        rm -f deploy.zip
      if: always()
