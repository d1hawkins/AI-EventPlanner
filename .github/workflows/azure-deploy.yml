name: Deploy to Azure

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        # Install main dependencies and test dependencies for CI
        poetry install --without google --no-root || (sleep 10 && poetry install --without google --no-root)
        # Install additional test dependencies to fix CI issues
        pip install psutil email-validator pytest
    
    - name: Create .env.test if missing and run tests
      run: |
        # Check if .env.test exists, if not create it
        if [ ! -f .env.test ]; then
          echo "Warning: .env.test not found. Creating default test environment file..."
          cat > .env.test << 'EOF'
        # AI Event Planner Test Environment Variables
        
        # OpenAI API Configuration (Required for real agents)
        OPENAI_API_KEY=sk-test-placeholder-for-testing
        
        # LLM Configuration
        LLM_MODEL=gpt-4
        LLM_PROVIDER=openai
        
        # Optional API Keys for enhanced functionality (use test/placeholder values)
        TAVILY_API_KEY=test_tavily_api_key_here
        GOOGLE_API_KEY=test_google_api_key_here
        SENDGRID_API_KEY=test_sendgrid_api_key_here
        OPENWEATHER_API_KEY=test_openweather_api_key_here
        
        # Database Configuration (Use in-memory SQLite for tests)
        DATABASE_URL=sqlite:///:memory:
        
        # Application Configuration
        SECRET_KEY=test_secret_key_for_testing_only
        DEBUG=false
        ENVIRONMENT=test
        
        # Server Configuration
        HOST=0.0.0.0
        PORT=8000
        EOF
        fi
        
        # Copy .env.test to .env for running tests
        cp .env.test .env
        
        # Export environment variables for tests
        set -a
        source .env
        set +a
        
        # Create mock MCP server file to prevent test failures
        mkdir -p mcp-servers/sendgrid-mcp/build
        echo "module.exports = {};" > mcp-servers/sendgrid-mcp/build/index.js
        
        # Run tests with CI optimizations for faster execution
        CI=true poetry run pytest -x --tb=short --disable-warnings -q
    
    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Configure Azure Web App for FastAPI deployment
      run: |
        set -euo pipefail

        # Use secrets (or hardcoded defaults)
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"                 # e.g. ai-event-planner-rg
        DESIRED_LOCATION="${{ secrets.AZURE_LOCATION }}"         # e.g. westus2 (optional)
        APP_NAME="ai-event-planner-saas-py"
        PLAN_NAME="ai-event-planner-plan"
        SKU="B1"

        echo "Resource Group: $RG"
        if az group show --name "$RG" >/dev/null 2>&1; then
          EXISTING_LOCATION=$(az group show --name "$RG" --query location -o tsv)
          echo "Resource group '$RG' already exists in location: $EXISTING_LOCATION"

          if [ -n "${DESIRED_LOCATION:-}" ] && [ "$DESIRED_LOCATION" != "$EXISTING_LOCATION" ]; then
            echo "Warning: desired location ($DESIRED_LOCATION) differs from existing group location ($EXISTING_LOCATION)."
            echo "Proceeding using existing resource group location: $EXISTING_LOCATION"
          fi

          LOCATION="$EXISTING_LOCATION"
        else
          # Create the resource group in DESIRED_LOCATION (fail if not provided)
          if [ -z "${DESIRED_LOCATION:-}" ]; then
            echo "ERROR: Resource group '$RG' does not exist and AZURE_LOCATION is not set. Set the AZURE_LOCATION secret or create the RG manually."
            exit 1
          fi
          echo "Creating resource group '$RG' in location: $DESIRED_LOCATION"
          az group create --name "$RG" --location "$DESIRED_LOCATION"
          LOCATION="$DESIRED_LOCATION"
        fi

        echo "Using Location: $LOCATION"

        # Create App Service plan if missing (Linux plan)
        if ! az appservice plan show --name "$PLAN_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating App Service plan: $PLAN_NAME"
          az appservice plan create --name "$PLAN_NAME" --resource-group "$RG" --sku "$SKU" --is-linux
        else
          echo "App Service plan '$PLAN_NAME' already exists."
        fi

        # Create the web app if missing (Python 3.10)
        if ! az webapp show --name "$APP_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating Web app: $APP_NAME"
          az webapp create --resource-group "$RG" --plan "$PLAN_NAME" --name "$APP_NAME" --runtime "PYTHON|3.10"
        else
          echo "Web app '$APP_NAME' already exists."
        fi

        # Configure critical app settings for FastAPI deployment
        echo "Configuring App Service settings for FastAPI..."
        
        # 1) Enable dependency building during deployment
        az webapp config appsettings set --resource-group "$RG" --name "$APP_NAME" --settings SCM_DO_BUILD_DURING_DEPLOYMENT=true
        
        # 2) Set Python runtime version explicitly
        az webapp config set --resource-group "$RG" --name "$APP_NAME" --linux-fx-version "PYTHON|3.10"
        
        # 3) Configure FastAPI startup command with gunicorn + uvicorn worker
        az webapp config set --resource-group "$RG" --name "$APP_NAME" --startup-file "gunicorn -w 4 -k uvicorn.workers.UvicornWorker --timeout 120 --bind 0.0.0.0:8000 app.main_saas:app"
        
        # 4) Enable Always On for reliability
        az webapp config appsettings set --resource-group "$RG" --name "$APP_NAME" --settings WEBSITES_ALWAYS_ON=true
        
        # 5) Configure additional reliability settings
        az webapp config appsettings set --resource-group "$RG" --name "$APP_NAME" --settings \
          WEBSITES_ENABLE_APP_SERVICE_STORAGE=true \
          WEBSITES_PORT=8000

    - name: Export requirements.txt for Azure build
      run: |
        # Install poetry export plugin (required for Poetry 2.0+)
        poetry self add poetry-plugin-export
        # Export locked dependencies for production (no dev)
        poetry export -f requirements.txt --output requirements.txt --without-hashes --only main
        
        # Ensure critical server packages are present
        echo "Ensuring gunicorn and uvicorn are in requirements.txt..."
        if ! grep -q "^gunicorn" requirements.txt; then
          echo "gunicorn==21.2.0" >> requirements.txt
        fi
        if ! grep -q "^uvicorn" requirements.txt; then
          echo "uvicorn[standard]==0.24.0" >> requirements.txt
        fi
        if ! grep -q "^fastapi" requirements.txt; then
          echo "fastapi==0.104.1" >> requirements.txt
        fi
        
        echo "requirements.txt generated with server packages (first 25 lines):"
        head -n 25 requirements.txt
    
    - name: Create deployment package with correct structure
      run: |
        # Create optimized deployment zip with files at webroot
        echo "Creating deployment package..."
        rm -f /tmp/app_deploy.zip
        
        # Include all necessary files at root level for proper Azure extraction
        zip -r /tmp/app_deploy.zip . \
          -x ".git/*" \
          -x ".github/*" \
          -x ".pytest_cache/*" \
          -x "__pycache__/*" \
          -x "tests/*" \
          -x "*.pyc" \
          -x ".env" \
          -x ".env.*" \
          -x "poetry.lock" \
          -x "pyproject.toml"
        
        echo "Deployment package created: /tmp/app_deploy.zip"
        echo "Package contents (top level):"
        unzip -l /tmp/app_deploy.zip | head -20

    - name: Deploy to Azure Web App using az CLI
      run: |
        set -euo pipefail
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        APP_NAME="ai-event-planner-saas-py"
        
        echo "Deploying application via az CLI zip deploy..."
        az webapp deployment source config-zip \
          --resource-group "$RG" \
          --name "$APP_NAME" \
          --src /tmp/app_deploy.zip \
          --verbose
        
        echo "Deployment upload completed successfully"

    - name: Wait for app startup and perform health check
      run: |
        set -euo pipefail
        APP_NAME="ai-event-planner-saas-py"
        
        echo "Waiting for application to start and become healthy..."
        SUCCESS=false
        
        for i in {1..30}; do
          echo "Health check attempt $i/30..."
          
          # Try to access the health endpoint first, then root endpoint
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$APP_NAME.azurewebsites.net/health" 2>/dev/null || echo "000")
          
          if [ "$STATUS" = "200" ]; then
            echo "Health endpoint responded with HTTP 200 - application is healthy!"
            SUCCESS=true
            break
          elif [ "$STATUS" = "000" ]; then
            # If health endpoint fails, try root endpoint
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$APP_NAME.azurewebsites.net/" 2>/dev/null || echo "000")
            if [ "$STATUS" = "200" ]; then
              echo "Root endpoint responded with HTTP 200 - application is healthy!"
              SUCCESS=true
              break
            fi
          fi
          
          if [ "$STATUS" = "503" ] || [ "$STATUS" = "502" ] || [ "$STATUS" = "000" ]; then
            echo "App returned $STATUS (service unavailable/starting up) - waiting..."
          else
            echo "App returned unexpected status: $STATUS - continuing to wait..."
          fi
          
          sleep 20
        done
        
        if [ "$SUCCESS" = "false" ]; then
          echo "ERROR: Application failed to become healthy within 10 minutes"
          exit 1
        fi
        
        echo "Application deployment and startup completed successfully!"

    - name: Comprehensive diagnostic logging on failure
      if: failure()
      run: |
        set -euo pipefail
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        APP_NAME="ai-event-planner-saas-py"
        USERNAME=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingUserName -o tsv)
        PASSWORD=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingPassword -o tsv)
        BASE="https://${APP_NAME}.scm.azurewebsites.net"
        
        echo "=== DEPLOYMENT FAILURE DIAGNOSTICS ==="
        
        echo "1. Latest deployment summary:"
        curl -s -u "$USERNAME:$PASSWORD" "$BASE/api/deployments/latest" | jq -r . || echo "Failed to get deployment summary"
        
        echo -e "\n2. Latest deployment log (first 1000 lines):"
        curl -s -u "$USERNAME:$PASSWORD" "$BASE/api/deployments/latest/log" | sed -n '1,1000p' || echo "Failed to get deployment log"
        
        echo -e "\n3. Container/runtime logs (docker logs):"
        curl -s -u "$USERNAME:$PASSWORD" "$BASE/api/logs/docker" | sed -n '1,1000p' || echo "Failed to get docker logs"
        
        echo -e "\n4. File system diagnostic - webroot contents:"
        curl -s -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$BASE/api/command" \
          -d '{"command":"bash -lc \"ls -la /home/site/wwwroot || true; echo '--- scripts directory ---'; ls -la /home/site/wwwroot/scripts || true; echo '--- app directory ---'; ls -la /home/site/wwwroot/app || true\"","dir":"/"}' | \
          sed -n '1,400p' || echo "Failed to list files"
        
        echo -e "\n5. Python environment check:"
        curl -s -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$BASE/api/command" \
          -d '{"command":"bash -lc \"python --version || python3 --version || true; which python || which python3 || true; pip list | head -20 || true\"","dir":"/home/site/wwwroot"}' | \
          sed -n '1,200p' || echo "Failed to check Python environment"
        
        echo -e "\n6. Startup command and process check:"
        curl -s -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$BASE/api/command" \
          -d '{"command":"bash -lc \"ps aux || true; echo '--- startup command check ---'; cat /home/LogFiles/*/default.log | tail -50 || true\"","dir":"/"}' | \
          sed -n '1,300p' || echo "Failed to check processes"
        
        echo -e "\n7. Application configuration:"
        az webapp config show --resource-group "$RG" --name "$APP_NAME" --query "{linuxFxVersion:linuxFxVersion,alwaysOn:siteProperties.alwaysOn,appSettings:appSettings}" || echo "Failed to get app config"
        
        echo -e "\n=== END DIAGNOSTICS ==="
    
    - name: Verify deployed files on Kudu
      run: |
        set -euo pipefail
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        APP_NAME="ai-event-planner-saas-py"
        USERNAME=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingUserName -o tsv)
        PASSWORD=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingPassword -o tsv)
        KUDU_BASE="https://${APP_NAME}.scm.azurewebsites.net/api/command"
        echo '{"command":"bash -lc \"ls -la /home/site/wwwroot || true; echo '--- /home/site/wwwroot/scripts ---'; ls -la /home/site/wwwroot/scripts || true\"","dir":"/"}' > /tmp/ls_root.json
        curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/ls_root.json | sed '$d'
    
    - name: Set migration skip flag
      run: echo "SKIP_MIGRATIONS=${{ secrets.SKIP_AZURE_MIGRATIONS || 'false' }}" >> $GITHUB_ENV
    
    - name: Run database migrations
      if: env.SKIP_MIGRATIONS != 'true'
      run: |
        set -euo pipefail

        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        APP_NAME="ai-event-planner-saas-py"
        # Get publishing creds
        if ! command -v jq &>/dev/null; then
          USERNAME=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingUserName -o tsv)
          PASSWORD=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingPassword -o tsv)
        else
          CREDS=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query "{username:publishingUserName, password:publishingPassword}" -o json)
          USERNAME=$(echo "$CREDS" | jq -r '.username')
          PASSWORD=$(echo "$CREDS" | jq -r '.password')
        fi

        KUDU_BASE="https://${APP_NAME}.scm.azurewebsites.net/api/command"

        echo "Finding Python executable path..."
        echo '{"command":"bash -lc \"which python3 || which python || command -v python3 || command -v python\"","dir":"/"}' > /tmp/find_python.json
        FIND_PYTHON_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/find_python.json)
        FIND_PYTHON_BODY=$(echo "$FIND_PYTHON_RESPONSE" | sed '$d')
        echo "Find Python response: $FIND_PYTHON_BODY"
        PYTHON_PATH=$(echo "$FIND_PYTHON_BODY" | grep -oE '/[A-Za-z0-9/_\.-]*python3?([0-9.]*)?' | head -n1 || true)
        if [ -n "$PYTHON_PATH" ]; then
          echo "Found Python path: $PYTHON_PATH"
        else
          echo "Python path not found; will use 'python3' from PATH on remote side."
          PYTHON_PATH="python3"
        fi

        # Install / bootstrap pip and install requirements (with retry and better error handling)
        echo "Installing remote dependencies with improved error handling..."
        cat > /tmp/install_reqs.json <<EOF
        {"command":"bash -lc \"set -e; ${PYTHON_PATH} -m ensurepip --upgrade 2>/dev/null || true; ${PYTHON_PATH} -m pip install --upgrade pip setuptools wheel 2>&1 || true; if [ -f /home/site/wwwroot/requirements.txt ]; then echo 'Installing requirements...'; ${PYTHON_PATH} -m pip install --no-cache-dir --prefer-binary -r /home/site/wwwroot/requirements.txt 2>&1 || echo 'PIP_INSTALL_FAILED'; else echo 'No requirements.txt found, skipping pip install'; fi\"","dir":"/"}
        EOF

        INSTALL_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/install_reqs.json)
        INSTALL_BODY=$(echo "$INSTALL_RESPONSE" | sed '$d')
        echo "Install response: $INSTALL_BODY"

        # If pip install printed PIP_INSTALL_FAILED marker, retry once and then fail with full logs
        if echo "$INSTALL_BODY" | grep -q "PIP_INSTALL_FAILED"; then
          echo "Initial pip install indicated failure. Retrying once..."
          # try a second time (capture)
          INSTALL_RESPONSE2=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/install_reqs.json)
          INSTALL_BODY2=$(echo "$INSTALL_RESPONSE2" | sed '$d')
          echo "Retry install response: $INSTALL_BODY2"
          if echo "$INSTALL_BODY2" | grep -q "PIP_INSTALL_FAILED"; then
            echo "Remote pip install failed after retry. Full response:"
            echo "$INSTALL_BODY2"
            # print a short remote environment diagnostic
            echo '{"command":"bash -lc \"python --version || true; uname -a || true; ls -la /home/site/wwwroot || true\"","dir":"/"}' > /tmp/diagnostic.json
            curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/diagnostic.json | sed '$d'
            exit 1
          fi
        fi

        # Verify migrate.py exists, upload scripts/ if missing
        echo "Verifying migration script exists on remote..."
        echo '{"command":"bash -lc \"test -f /home/site/wwwroot/scripts/migrate.py && echo OK || echo MISSING\"","dir":"/"}' > /tmp/check_migrate.json
        CHECK_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/check_migrate.json)
        CHECK_BODY=$(echo "$CHECK_RESPONSE" | sed '$d')
        echo "Check response: $CHECK_BODY"
        IS_PRESENT=$(echo "$CHECK_BODY" | grep -o "OK" || true)

        if [ -z "$IS_PRESENT" ]; then
          echo "migrate.py not found on remote. Uploading local scripts/ directory via Kudu zip deploy..."
          if [ ! -d "scripts" ]; then
            echo "ERROR: Local scripts/ directory not found in repo workspace. Ensure scripts/ is committed."
            exit 1
          fi
          # create zip
          zip -r /tmp/scripts_deploy.zip scripts >/dev/null

          # Use az CLI zip deploy (more reliable than ad-hoc Kudu curl in this runner)
          echo "Deploying scripts via az webapp deployment source config-zip..."
          az webapp deployment source config-zip --resource-group "$RG" --name "$APP_NAME" --src /tmp/scripts_deploy.zip --verbose || {
            echo "ERROR: az webapp deployment source config-zip failed"
            echo '{"command":"bash -lc \"ls -la /home/site/wwwroot || true; ls -la /home/site/wwwroot/scripts || true\"","dir":"/"}' > /tmp/ls_root.json
            curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/ls_root.json | sed '$d'
            exit 1
          }

          # Give Kudu a few seconds to extract / propagate
          echo "Waiting 5s for deployment to complete..."
          sleep 5

          # Re-check presence
          CHECK_RESPONSE2=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
            -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/check_migrate.json)
          CHECK_BODY2=$(echo "$CHECK_RESPONSE2" | sed '$d')
          echo "Re-check response: $CHECK_BODY2"
          IS_PRESENT2=$(echo "$CHECK_BODY2" | grep -o "OK" || true)
          if [ -z "$IS_PRESENT2" ]; then
            echo "ERROR: migrate.py is still missing after az zip deploy. Remote listing for debug:"
            echo '{"command":"bash -lc \"ls -la /home/site/wwwroot || true; ls -la /home/site/wwwroot/scripts || true\"","dir":"/"}' > /tmp/ls_root.json
            curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/ls_root.json | sed '$d'
            exit 1
          fi
          echo "Upload succeeded and migrate.py present."
        else
          echo "migrate.py already present on remote."
        fi

        # Run migrations
        echo "Running migrations with command: $PYTHON_PATH /home/site/wwwroot/scripts/migrate.py"
        echo "{\"command\":\"$PYTHON_PATH /home/site/wwwroot/scripts/migrate.py\",\"dir\":\"/home/site/wwwroot\"}" > /tmp/migrate.json
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/migrate.json)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
        echo "Migration response: $RESPONSE_BODY"
        EXIT_CODE=$(echo "$RESPONSE_BODY" | grep -o '"ExitCode":[[:space:]]*[0-9]\+' | grep -o '[0-9]\+' || echo "")
        if [ -z "$EXIT_CODE" ]; then
          echo "Warning: Could not detect ExitCode in migration response. Failing for safety."
          echo "$RESPONSE_BODY"
          exit 1
        fi
        if [ "$EXIT_CODE" -ne 0 ]; then
          echo "Migration failed with ExitCode $EXIT_CODE"
          echo "Response: $RESPONSE_BODY"
          # show remote working dir for debugging
          echo "{\"command\":\"bash -lc 'pwd; ls -la /home/site/wwwroot || true'\",\"dir\":\"/\"}" > /tmp/diag2.json
          curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/diag2.json | sed '$d'
          exit 1
        fi

        # Clean up
        rm -f /tmp/find_python.json /tmp/install_reqs.json /tmp/migrate.json /tmp/check_migrate.json /tmp/ls_root.json /tmp/scripts_deploy.zip /tmp/get-pip.py /tmp/diagnostic.json /tmp/diag2.json
        echo "Migration completed successfully"
