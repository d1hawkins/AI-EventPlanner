name: Deploy to Azure

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        poetry install --without google --no-root || (sleep 10 && poetry install --without google --no-root)
        # Install additional test dependencies to fix CI issues
        pip install psutil email-validator
    
    - name: Create .env.test if missing and run tests
      run: |
        # Check if .env.test exists, if not create it
        if [ ! -f .env.test ]; then
          echo "Warning: .env.test not found. Creating default test environment file..."
          cat > .env.test << 'EOF'
        # AI Event Planner Test Environment Variables
        
        # OpenAI API Configuration (Required for real agents)
        OPENAI_API_KEY=sk-test-placeholder-for-testing
        
        # LLM Configuration
        LLM_MODEL=gpt-4
        LLM_PROVIDER=openai
        
        # Optional API Keys for enhanced functionality (use test/placeholder values)
        TAVILY_API_KEY=test_tavily_api_key_here
        GOOGLE_API_KEY=test_google_api_key_here
        SENDGRID_API_KEY=test_sendgrid_api_key_here
        OPENWEATHER_API_KEY=test_openweather_api_key_here
        
        # Database Configuration (Use in-memory SQLite for tests)
        DATABASE_URL=sqlite:///:memory:
        
        # Application Configuration
        SECRET_KEY=test_secret_key_for_testing_only
        DEBUG=false
        ENVIRONMENT=test
        
        # Server Configuration
        HOST=0.0.0.0
        PORT=8000
        EOF
        fi
        
        # Copy .env.test to .env for running tests
        cp .env.test .env
        
        # Export environment variables for tests
        set -a
        source .env
        set +a
        
        # Create mock MCP server file to prevent test failures
        mkdir -p mcp-servers/sendgrid-mcp/build
        echo "module.exports = {};" > mcp-servers/sendgrid-mcp/build/index.js
        
        # Run tests with CI optimizations for faster execution
        CI=true poetry run pytest -x --tb=short --disable-warnings -q
    
    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Ensure Azure Web App exists (create if missing / respect existing RG location)
      run: |
        set -euo pipefail

        # Use secrets (or hardcoded defaults)
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"                 # e.g. ai-event-planner-rg
        DESIRED_LOCATION="${{ secrets.AZURE_LOCATION }}"         # e.g. westus2 (optional)
        APP_NAME="ai-event-planner-saas-py"
        PLAN_NAME="ai-event-planner-plan"
        SKU="B1"

        echo "Resource Group: $RG"
        if az group show --name "$RG" >/dev/null 2>&1; then
          EXISTING_LOCATION=$(az group show --name "$RG" --query location -o tsv)
          echo "Resource group '$RG' already exists in location: $EXISTING_LOCATION"

          if [ -n "${DESIRED_LOCATION:-}" ] && [ "$DESIRED_LOCATION" != "$EXISTING_LOCATION" ]; then
            echo "Warning: desired location ($DESIRED_LOCATION) differs from existing group location ($EXISTING_LOCATION)."
            echo "Proceeding using existing resource group location: $EXISTING_LOCATION"
          fi

          LOCATION="$EXISTING_LOCATION"
        else
          # Create the resource group in DESIRED_LOCATION (fail if not provided)
          if [ -z "${DESIRED_LOCATION:-}" ]; then
            echo "ERROR: Resource group '$RG' does not exist and AZURE_LOCATION is not set. Set the AZURE_LOCATION secret or create the RG manually."
            exit 1
          fi
          echo "Creating resource group '$RG' in location: $DESIRED_LOCATION"
          az group create --name "$RG" --location "$DESIRED_LOCATION"
          LOCATION="$DESIRED_LOCATION"
        fi

        echo "Using Location: $LOCATION"

        # Create App Service plan if missing (Linux plan)
        if ! az appservice plan show --name "$PLAN_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating App Service plan: $PLAN_NAME"
          az appservice plan create --name "$PLAN_NAME" --resource-group "$RG" --sku "$SKU" --is-linux
        else
          echo "App Service plan '$PLAN_NAME' already exists."
        fi

        # Create the web app if missing (Python 3.10)
        if ! az webapp show --name "$APP_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating Web app: $APP_NAME"
          az webapp create --resource-group "$RG" --plan "$PLAN_NAME" --name "$APP_NAME" --runtime "PYTHON|3.10"
        else
          echo "Web app '$APP_NAME' already exists."
        fi
    
    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: 'ai-event-planner-saas-py'
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: .
    
    - name: Run database migrations
      run: |
        set -euo pipefail

        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        APP_NAME="ai-event-planner-saas-py"
        # Retrieve publishing credentials (use az CLI directly if jq not available)
        if ! command -v jq &>/dev/null; then
          USERNAME=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingUserName -o tsv)
          PASSWORD=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingPassword -o tsv)
        else
          CREDS=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query "{username:publishingUserName, password:publishingPassword}" -o json)
          USERNAME=$(echo "$CREDS" | jq -r '.username')
          PASSWORD=$(echo "$CREDS" | jq -r '.password')
        fi

        # Helper: post to Kudu using a temporary JSON file to avoid quoting problems
        KUDU_BASE="https://${APP_NAME}.scm.azurewebsites.net/api/command"

        echo "Finding Python executable path..."
        echo '{"command":"bash -lc \"which python3 || which python || command -v python3 || command -v python\"","dir":"/"}' > /tmp/find_python.json

        FIND_PYTHON_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
          -H "Content-Type: application/json" \
          "$KUDU_BASE" \
          -d @/tmp/find_python.json)

        FIND_PYTHON_BODY=$(echo "$FIND_PYTHON_RESPONSE" | sed '$d')
        echo "Find Python response: $FIND_PYTHON_BODY"

        # Extract python path (if any)
        PYTHON_PATH=$(echo "$FIND_PYTHON_BODY" | grep -oE '/[A-Za-z0-9/_\.-]*python3?([0-9.]*)?' | head -n1 || true)
        if [ -n "$PYTHON_PATH" ]; then
          echo "Found Python path: $PYTHON_PATH"
        else
          echo "Python path not found; will use 'python3' from PATH on remote side."
          PYTHON_PATH="python3"
        fi

        # 1) Ensure dependencies installed on the remote host with robust pip bootstrap
        echo "Installing remote dependencies..."
        echo "{\"command\":\"bash -lc \\\"set -e; $PYTHON_PATH -m ensurepip --upgrade 2>/dev/null || true; $PYTHON_PATH -m pip install --upgrade pip 2>/dev/null || (curl -sS https://bootstrap.pypa.io/get-pip.py -o /tmp/get-pip.py && $PYTHON_PATH /tmp/get-pip.py); $PYTHON_PATH -m pip install -r /home/site/wwwroot/requirements.txt --no-cache-dir\\\"\",\"dir\":\"/home/site/wwwroot\"}" > /tmp/install_reqs.json

        INSTALL_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
          -H "Content-Type: application/json" \
          "$KUDU_BASE" \
          -d @/tmp/install_reqs.json)
        INSTALL_BODY=$(echo "$INSTALL_RESPONSE" | sed '$d')
        echo "Install response: $INSTALL_BODY"
        INSTALL_EXIT=$(echo "$INSTALL_BODY" | grep -o '"ExitCode":[[:space:]]*[0-9]\+' | grep -o '[0-9]\+' || echo "")

        if [ -z "$INSTALL_EXIT" ]; then
          echo "Could not determine pip install exit code. Full response:"
          echo "$INSTALL_BODY"
          exit 1
        fi
        if [ "$INSTALL_EXIT" -ne 0 ]; then
          echo "Remote pip install failed (ExitCode $INSTALL_EXIT). Response:"
          echo "$INSTALL_BODY"
          exit 1
        fi

        # 2) Run migration by invoking the script file directly (avoid -m import issues)
        echo "Running migrations with command: $PYTHON_PATH /home/site/wwwroot/scripts/migrate.py"
        echo "{\"command\":\"$PYTHON_PATH /home/site/wwwroot/scripts/migrate.py\",\"dir\":\"/home/site/wwwroot\"}" > /tmp/migrate.json

        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
          -H "Content-Type: application/json" \
          "$KUDU_BASE" \
          -d @/tmp/migrate.json)

        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
        echo "Migration response: $RESPONSE_BODY"

        EXIT_CODE=$(echo "$RESPONSE_BODY" | grep -o '"ExitCode":[[:space:]]*[0-9]\+' | grep -o '[0-9]\+' || echo "")

        if [ -z "$EXIT_CODE" ]; then
          echo "Warning: Could not detect ExitCode in migration response. Failing for safety."
          echo "$RESPONSE_BODY"
          exit 1
        fi

        if [ "$EXIT_CODE" -ne 0 ]; then
          echo "Migration failed with ExitCode $EXIT_CODE"
          echo "Response: $RESPONSE_BODY"
          exit 1
        fi

        # Clean up temp files
        rm -f /tmp/find_python.json /tmp/install_reqs.json /tmp/migrate.json /tmp/get-pip.py

        echo "Migration completed successfully"
