name: Deploy to Azure

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        poetry install --without google --no-root || (sleep 10 && poetry install --without google --no-root)
        # Install additional test dependencies to fix CI issues
        pip install psutil email-validator
    
    - name: Create .env.test if missing and run tests
      run: |
        # Check if .env.test exists, if not create it
        if [ ! -f .env.test ]; then
          echo "Warning: .env.test not found. Creating default test environment file..."
          cat > .env.test << 'EOF'
        # AI Event Planner Test Environment Variables
        
        # OpenAI API Configuration (Required for real agents)
        OPENAI_API_KEY=sk-test-placeholder-for-testing
        
        # LLM Configuration
        LLM_MODEL=gpt-4
        LLM_PROVIDER=openai
        
        # Optional API Keys for enhanced functionality (use test/placeholder values)
        TAVILY_API_KEY=test_tavily_api_key_here
        GOOGLE_API_KEY=test_google_api_key_here
        SENDGRID_API_KEY=test_sendgrid_api_key_here
        OPENWEATHER_API_KEY=test_openweather_api_key_here
        
        # Database Configuration (Use in-memory SQLite for tests)
        DATABASE_URL=sqlite:///:memory:
        
        # Application Configuration
        SECRET_KEY=test_secret_key_for_testing_only
        DEBUG=false
        ENVIRONMENT=test
        
        # Server Configuration
        HOST=0.0.0.0
        PORT=8000
        EOF
        fi
        
        # Copy .env.test to .env for running tests
        cp .env.test .env
        
        # Export environment variables for tests
        set -a
        source .env
        set +a
        
        # Create mock MCP server file to prevent test failures
        mkdir -p mcp-servers/sendgrid-mcp/build
        echo "module.exports = {};" > mcp-servers/sendgrid-mcp/build/index.js
        
        # Run tests with CI optimizations for faster execution
        CI=true poetry run pytest -x --tb=short --disable-warnings -q
    
    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Ensure Azure Web App exists (create if missing / respect existing RG location)
      run: |
        set -euo pipefail

        # Use secrets (or hardcoded defaults)
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"                 # e.g. ai-event-planner-rg
        DESIRED_LOCATION="${{ secrets.AZURE_LOCATION }}"         # e.g. westus2 (optional)
        APP_NAME="ai-event-planner-saas-py"
        PLAN_NAME="ai-event-planner-plan"
        SKU="B1"

        echo "Resource Group: $RG"
        if az group show --name "$RG" >/dev/null 2>&1; then
          EXISTING_LOCATION=$(az group show --name "$RG" --query location -o tsv)
          echo "Resource group '$RG' already exists in location: $EXISTING_LOCATION"

          if [ -n "${DESIRED_LOCATION:-}" ] && [ "$DESIRED_LOCATION" != "$EXISTING_LOCATION" ]; then
            echo "Warning: desired location ($DESIRED_LOCATION) differs from existing group location ($EXISTING_LOCATION)."
            echo "Proceeding using existing resource group location: $EXISTING_LOCATION"
          fi

          LOCATION="$EXISTING_LOCATION"
        else
          # Create the resource group in DESIRED_LOCATION (fail if not provided)
          if [ -z "${DESIRED_LOCATION:-}" ]; then
            echo "ERROR: Resource group '$RG' does not exist and AZURE_LOCATION is not set. Set the AZURE_LOCATION secret or create the RG manually."
            exit 1
          fi
          echo "Creating resource group '$RG' in location: $DESIRED_LOCATION"
          az group create --name "$RG" --location "$DESIRED_LOCATION"
          LOCATION="$DESIRED_LOCATION"
        fi

        echo "Using Location: $LOCATION"

        # Create App Service plan if missing (Linux plan)
        if ! az appservice plan show --name "$PLAN_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating App Service plan: $PLAN_NAME"
          az appservice plan create --name "$PLAN_NAME" --resource-group "$RG" --sku "$SKU" --is-linux
        else
          echo "App Service plan '$PLAN_NAME' already exists."
        fi

        # Create the web app if missing (Python 3.10)
        if ! az webapp show --name "$APP_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating Web app: $APP_NAME"
          az webapp create --resource-group "$RG" --plan "$PLAN_NAME" --name "$APP_NAME" --runtime "PYTHON|3.10"
        else
          echo "Web app '$APP_NAME' already exists."
        fi

        # Configure app to build during deployment for more robust dependency management
        echo "Setting SCM_DO_BUILD_DURING_DEPLOYMENT=true for robust dependency installation"
        az webapp config appsettings set --resource-group "$RG" --name "$APP_NAME" --settings SCM_DO_BUILD_DURING_DEPLOYMENT=true
    
    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: 'ai-event-planner-saas-py'
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: .
    
    - name: Verify deployed files on Kudu
      run: |
        set -euo pipefail
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        APP_NAME="ai-event-planner-saas-py"
        USERNAME=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingUserName -o tsv)
        PASSWORD=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingPassword -o tsv)
        KUDU_BASE="https://${APP_NAME}.scm.azurewebsites.net/api/command"
        echo '{"command":"bash -lc \"ls -la /home/site/wwwroot || true; echo '--- /home/site/wwwroot/scripts ---'; ls -la /home/site/wwwroot/scripts || true\"","dir":"/"}' > /tmp/ls_root.json
        curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/ls_root.json | sed '$d'
    
    - name: Set migration skip flag
      run: echo "SKIP_MIGRATIONS=${{ secrets.SKIP_AZURE_MIGRATIONS || 'false' }}" >> $GITHUB_ENV
    
    - name: Run database migrations
      if: env.SKIP_MIGRATIONS != 'true'
      run: |
        set -euo pipefail

        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"
        APP_NAME="ai-event-planner-saas-py"
        # Get publishing creds
        if ! command -v jq &>/dev/null; then
          USERNAME=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingUserName -o tsv)
          PASSWORD=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query publishingPassword -o tsv)
        else
          CREDS=$(az webapp deployment list-publishing-credentials --resource-group "$RG" --name "$APP_NAME" --query "{username:publishingUserName, password:publishingPassword}" -o json)
          USERNAME=$(echo "$CREDS" | jq -r '.username')
          PASSWORD=$(echo "$CREDS" | jq -r '.password')
        fi

        KUDU_BASE="https://${APP_NAME}.scm.azurewebsites.net/api/command"

        echo "Finding Python executable path..."
        echo '{"command":"bash -lc \"which python3 || which python || command -v python3 || command -v python\"","dir":"/"}' > /tmp/find_python.json
        FIND_PYTHON_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/find_python.json)
        FIND_PYTHON_BODY=$(echo "$FIND_PYTHON_RESPONSE" | sed '$d')
        echo "Find Python response: $FIND_PYTHON_BODY"
        PYTHON_PATH=$(echo "$FIND_PYTHON_BODY" | grep -oE '/[A-Za-z0-9/_\.-]*python3?([0-9.]*)?' | head -n1 || true)
        if [ -n "$PYTHON_PATH" ]; then
          echo "Found Python path: $PYTHON_PATH"
        else
          echo "Python path not found; will use 'python3' from PATH on remote side."
          PYTHON_PATH="python3"
        fi

        # Install / bootstrap pip and install requirements (with retry and better error handling)
        echo "Installing remote dependencies with improved error handling..."
        cat > /tmp/install_reqs.json <<EOF
        {"command":"bash -lc \"set -e; ${PYTHON_PATH} -m ensurepip --upgrade 2>/dev/null || true; ${PYTHON_PATH} -m pip install --upgrade pip setuptools wheel 2>&1 || true; if [ -f /home/site/wwwroot/requirements.txt ]; then echo 'Installing requirements...'; ${PYTHON_PATH} -m pip install --no-cache-dir --prefer-binary -r /home/site/wwwroot/requirements.txt 2>&1 || echo 'PIP_INSTALL_FAILED'; else echo 'No requirements.txt found, skipping pip install'; fi\"","dir":"/"}
        EOF

        INSTALL_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/install_reqs.json)
        INSTALL_BODY=$(echo "$INSTALL_RESPONSE" | sed '$d')
        echo "Install response: $INSTALL_BODY"

        # If pip install printed PIP_INSTALL_FAILED marker, retry once and then fail with full logs
        if echo "$INSTALL_BODY" | grep -q "PIP_INSTALL_FAILED"; then
          echo "Initial pip install indicated failure. Retrying once..."
          # try a second time (capture)
          INSTALL_RESPONSE2=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/install_reqs.json)
          INSTALL_BODY2=$(echo "$INSTALL_RESPONSE2" | sed '$d')
          echo "Retry install response: $INSTALL_BODY2"
          if echo "$INSTALL_BODY2" | grep -q "PIP_INSTALL_FAILED"; then
            echo "Remote pip install failed after retry. Full response:"
            echo "$INSTALL_BODY2"
            # print a short remote environment diagnostic
            echo '{"command":"bash -lc \"python --version || true; uname -a || true; ls -la /home/site/wwwroot || true\"","dir":"/"}' > /tmp/diagnostic.json
            curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/diagnostic.json | sed '$d'
            exit 1
          fi
        fi

        # Verify migrate.py exists, upload scripts/ if missing
        echo "Verifying migration script exists on remote..."
        echo '{"command":"bash -lc \"test -f /home/site/wwwroot/scripts/migrate.py && echo OK || echo MISSING\"","dir":"/"}' > /tmp/check_migrate.json
        CHECK_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/check_migrate.json)
        CHECK_BODY=$(echo "$CHECK_RESPONSE" | sed '$d')
        echo "Check response: $CHECK_BODY"
        IS_PRESENT=$(echo "$CHECK_BODY" | grep -o "OK" || true)

        if [ -z "$IS_PRESENT" ]; then
          echo "migrate.py not found on remote. Uploading local scripts/ directory via Kudu zip deploy..."
          if [ ! -d "scripts" ]; then
            echo "ERROR: Local scripts/ directory not found in repo workspace. Ensure scripts/ is committed."
            exit 1
          fi
          # create zip
          zip -r /tmp/scripts_deploy.zip scripts >/dev/null

          # upload to Kudu zipdeploy endpoint
          UPLOAD_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
            -H "Content-Type: application/zip" --data-binary @/tmp/scripts_deploy.zip \
            "https://${APP_NAME}.scm.azurewebsites.net/api/zipdeploy")

          UPLOAD_BODY=$(echo "$UPLOAD_RESPONSE" | sed '$d')
          UPLOAD_CODE=$(echo "$UPLOAD_RESPONSE" | tail -n1)
          echo "Upload response body: $UPLOAD_BODY"
          echo "Upload http code: $UPLOAD_CODE"

          if [ "$UPLOAD_CODE" -lt 200 ] || [ "$UPLOAD_CODE" -ge 300 ]; then
            echo "ERROR: Zip upload failed (http code: $UPLOAD_CODE). Full response:"
            echo "$UPLOAD_BODY"
            # Show remote debug listing
            echo '{"command":"bash -lc \"ls -la /home/site/wwwroot || true\"","dir":"/"}' > /tmp/ls_root.json
            curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/ls_root.json | sed '$d'
            exit 1
          fi

          # Re-check presence
          CHECK_RESPONSE2=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/check_migrate.json)
          CHECK_BODY2=$(echo "$CHECK_RESPONSE2" | sed '$d')
          echo "Re-check response: $CHECK_BODY2"
          IS_PRESENT2=$(echo "$CHECK_BODY2" | grep -o "OK" || true)
          if [ -z "$IS_PRESENT2" ]; then
            echo "ERROR: migrate.py is still missing after upload. Remote listing for debug:"
            echo "{\"command\":\"bash -lc 'ls -la /home/site/wwwroot || true'\",\"dir\":\"/\"}" > /tmp/ls_root.json
            curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/ls_root.json | sed '$d'
            exit 1
          fi
          echo "Upload succeeded and migrate.py present."
        else
          echo "migrate.py already present on remote."
        fi

        # Run migrations
        echo "Running migrations with command: $PYTHON_PATH /home/site/wwwroot/scripts/migrate.py"
        echo "{\"command\":\"$PYTHON_PATH /home/site/wwwroot/scripts/migrate.py\",\"dir\":\"/home/site/wwwroot\"}" > /tmp/migrate.json
        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/migrate.json)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')
        echo "Migration response: $RESPONSE_BODY"
        EXIT_CODE=$(echo "$RESPONSE_BODY" | grep -o '"ExitCode":[[:space:]]*[0-9]\+' | grep -o '[0-9]\+' || echo "")
        if [ -z "$EXIT_CODE" ]; then
          echo "Warning: Could not detect ExitCode in migration response. Failing for safety."
          echo "$RESPONSE_BODY"
          exit 1
        fi
        if [ "$EXIT_CODE" -ne 0 ]; then
          echo "Migration failed with ExitCode $EXIT_CODE"
          echo "Response: $RESPONSE_BODY"
          # show remote working dir for debugging
          echo "{\"command\":\"bash -lc 'pwd; ls -la /home/site/wwwroot || true'\",\"dir\":\"/\"}" > /tmp/diag2.json
          curl -s -X POST -u "$USERNAME:$PASSWORD" -H "Content-Type: application/json" "$KUDU_BASE" -d @/tmp/diag2.json | sed '$d'
          exit 1
        fi

        # Clean up
        rm -f /tmp/find_python.json /tmp/install_reqs.json /tmp/migrate.json /tmp/check_migrate.json /tmp/ls_root.json /tmp/scripts_deploy.zip /tmp/get-pip.py /tmp/diagnostic.json /tmp/diag2.json
        echo "Migration completed successfully"
