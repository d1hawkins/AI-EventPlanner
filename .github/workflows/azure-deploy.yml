name: Deploy to Azure

on:
  push:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install poetry
        poetry install --without google --no-root || (sleep 10 && poetry install --without google --no-root)
        # Install additional test dependencies to fix CI issues
        pip install psutil email-validator
    
    - name: Create .env.test if missing and run tests
      run: |
        # Check if .env.test exists, if not create it
        if [ ! -f .env.test ]; then
          echo "Warning: .env.test not found. Creating default test environment file..."
          cat > .env.test << 'EOF'
        # AI Event Planner Test Environment Variables
        
        # OpenAI API Configuration (Required for real agents)
        OPENAI_API_KEY=sk-test-placeholder-for-testing
        
        # LLM Configuration
        LLM_MODEL=gpt-4
        LLM_PROVIDER=openai
        
        # Optional API Keys for enhanced functionality (use test/placeholder values)
        TAVILY_API_KEY=test_tavily_api_key_here
        GOOGLE_API_KEY=test_google_api_key_here
        SENDGRID_API_KEY=test_sendgrid_api_key_here
        OPENWEATHER_API_KEY=test_openweather_api_key_here
        
        # Database Configuration (Use in-memory SQLite for tests)
        DATABASE_URL=sqlite:///:memory:
        
        # Application Configuration
        SECRET_KEY=test_secret_key_for_testing_only
        DEBUG=false
        ENVIRONMENT=test
        
        # Server Configuration
        HOST=0.0.0.0
        PORT=8000
        EOF
        fi
        
        # Copy .env.test to .env for running tests
        cp .env.test .env
        
        # Export environment variables for tests
        set -a
        source .env
        set +a
        
        # Create mock MCP server file to prevent test failures
        mkdir -p mcp-servers/sendgrid-mcp/build
        echo "module.exports = {};" > mcp-servers/sendgrid-mcp/build/index.js
        
        # Run tests with CI optimizations for faster execution
        CI=true poetry run pytest -x --tb=short --disable-warnings -q
    
    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Ensure Azure Web App exists (create if missing / respect existing RG location)
      run: |
        set -euo pipefail

        # Use secrets (or hardcoded defaults)
        RG="${{ secrets.AZURE_RESOURCE_GROUP }}"                 # e.g. ai-event-planner-rg
        DESIRED_LOCATION="${{ secrets.AZURE_LOCATION }}"         # e.g. westus2 (optional)
        APP_NAME="ai-event-planner-saas-py"
        PLAN_NAME="ai-event-planner-plan"
        SKU="B1"

        echo "Resource Group: $RG"
        if az group show --name "$RG" >/dev/null 2>&1; then
          EXISTING_LOCATION=$(az group show --name "$RG" --query location -o tsv)
          echo "Resource group '$RG' already exists in location: $EXISTING_LOCATION"

          if [ -n "${DESIRED_LOCATION:-}" ] && [ "$DESIRED_LOCATION" != "$EXISTING_LOCATION" ]; then
            echo "Warning: desired location ($DESIRED_LOCATION) differs from existing group location ($EXISTING_LOCATION)."
            echo "Proceeding using existing resource group location: $EXISTING_LOCATION"
          fi

          LOCATION="$EXISTING_LOCATION"
        else
          # Create the resource group in DESIRED_LOCATION (fail if not provided)
          if [ -z "${DESIRED_LOCATION:-}" ]; then
            echo "ERROR: Resource group '$RG' does not exist and AZURE_LOCATION is not set. Set the AZURE_LOCATION secret or create the RG manually."
            exit 1
          fi
          echo "Creating resource group '$RG' in location: $DESIRED_LOCATION"
          az group create --name "$RG" --location "$DESIRED_LOCATION"
          LOCATION="$DESIRED_LOCATION"
        fi

        echo "Using Location: $LOCATION"

        # Create App Service plan if missing (Linux plan)
        if ! az appservice plan show --name "$PLAN_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating App Service plan: $PLAN_NAME"
          az appservice plan create --name "$PLAN_NAME" --resource-group "$RG" --sku "$SKU" --is-linux
        else
          echo "App Service plan '$PLAN_NAME' already exists."
        fi

        # Create the web app if missing (Python 3.10)
        if ! az webapp show --name "$APP_NAME" --resource-group "$RG" >/dev/null 2>&1; then
          echo "Creating Web app: $APP_NAME"
          az webapp create --resource-group "$RG" --plan "$PLAN_NAME" --name "$APP_NAME" --runtime "PYTHON|3.10"
        else
          echo "Web app '$APP_NAME' already exists."
        fi
    
    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: 'ai-event-planner-saas-py'
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE }}
        package: .
    
    - name: Run database migrations
      run: |
        # Get publishing credentials
        CREDS=$(az webapp deployment list-publishing-credentials --resource-group ${{ secrets.AZURE_RESOURCE_GROUP }} --name ai-event-planner-saas-py --query "{username:publishingUserName, password:publishingPassword}" -o json)
        USERNAME=$(echo $CREDS | jq -r '.username')
        PASSWORD=$(echo $CREDS | jq -r '.password')
        
        # First, find the Python executable path (use temp files to avoid JSON quoting issues)
        echo "Finding Python executable path..."
        echo '{"command":"bash -lc \"which python3 || which python || command -v python3 || command -v python\"","dir":"/"}' > /tmp/find_python.json

        FIND_PYTHON_RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
          -H "Content-Type: application/json" \
          https://ai-event-planner-saas-py.scm.azurewebsites.net/api/command \
          -d @/tmp/find_python.json)

        FIND_PYTHON_HTTP_STATUS=$(echo "$FIND_PYTHON_RESPONSE" | tail -n1)
        FIND_PYTHON_BODY=$(echo "$FIND_PYTHON_RESPONSE" | sed '$d')

        echo "Find Python response: $FIND_PYTHON_BODY"
        echo "HTTP status: $FIND_PYTHON_HTTP_STATUS"

        # Extract a path-like python result if present
        PYTHON_PATH=$(echo "$FIND_PYTHON_BODY" | grep -oE '/[A-Za-z0-9/_\.-]*python3?([0-9.]*)?' | head -n 1 || true)

        if [ -n "$PYTHON_PATH" ]; then
          echo "Found Python path: $PYTHON_PATH"
        else
          echo "Python path not found via which; will try PATH-based invocation (python3 or python)."
          PYTHON_PATH=""
        fi

        # Build migration command: prefer absolute path if found, otherwise try python3 or python via bash -lc so PATH is available
        if [ -n "$PYTHON_PATH" ]; then
          MIGRATE_CMD="$PYTHON_PATH -m scripts.migrate"
        else
          MIGRATE_CMD='bash -lc "python3 -m scripts.migrate || python -m scripts.migrate"'
        fi

        echo "Running migrations with command: $MIGRATE_CMD"
        echo "{\"command\":\"$MIGRATE_CMD\",\"dir\":\"/home/site/wwwroot\"}" > /tmp/migrate.json

        RESPONSE=$(curl -s -w "\n%{http_code}" -X POST -u "$USERNAME:$PASSWORD" \
          -H "Content-Type: application/json" \
          https://ai-event-planner-saas-py.scm.azurewebsites.net/api/command \
          -d @/tmp/migrate.json)

        HTTP_STATUS=$(echo "$RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$RESPONSE" | sed '$d')

        echo "Migration response: $RESPONSE_BODY"
        echo "HTTP status: $HTTP_STATUS"

        # Extract ExitCode from the response body (Kudu returns JSON with ExitCode inside body even if HTTP 200)
        EXIT_CODE=$(echo "$RESPONSE_BODY" | grep -o '"ExitCode":[[:space:]]*[0-9]\+' | grep -o '[0-9]\+' || echo "")

        if [ -z "$EXIT_CODE" ]; then
          echo "Warning: Could not detect ExitCode in response. Failing for safety."
          echo "$RESPONSE_BODY"
          exit 1
        fi

        if [ "$EXIT_CODE" -ne 0 ]; then
          echo "Migration failed with ExitCode $EXIT_CODE"
          echo "Response: $RESPONSE_BODY"
          exit 1
        fi

        # Clean up temp files
        rm -f /tmp/find_python.json /tmp/migrate.json
        
        echo "Migration completed successfully"
